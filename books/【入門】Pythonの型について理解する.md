# 【入門】Pythonを書く前に知っておきたいデータ型のあれこれ

## 1. はじめに

Pythonを書く前にデータ型について、最低限知っておいてほしいことをまとめました。

※ 対象とするPythonのバージョンは`3.11`までとします。

## 2. データ型とは

メモリの2進数情報を変換した時の解釈物です。

> 01000001(2進数) -> 65(10進数)

例えばC言語の基本データ型である`char`は1バイト(-128～127の値)記憶できます。  
(英数字などの１バイト文字を１字記憶できます。上記例だと`A`が割り当てられています。)

Pythonでも、もちろん同じ原理です。
(Python3以降から[Unicode](https://docs.python.org/ja/3/howto/unicode.html)が標準です)

```py
# Aのコードポイントを2進数で出力
bin(ord('A'))
>>> '0b1000001'
```

## 3. データ型の種類について

「組み込み型(プリミティブ型)」と「複合型(コンポジット型)」があります。  
この2つはよく対比されますが、対照的な概念ではないです。  
どちらかというと、ラッパーとかそういうイメージに近いです。

### 3.1. 組み込み型

各プログラミング言語が規定している基本的なデータ型。(例. char, int, float, bool 等)  
そのため、ある言語では複合型に分類されるデータ型も別の言語では組み込み型になる可能性があります。

### 3.2. 複合型

> プリミティブ型および複合データ型の構造的または再帰的な組み合わせ（コンポジション）で形成されるデータ型

([wikipedia](https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B)参照)

構造体や、配列やリストなどはそれらに該当することが多いです。

### 3.3. Pythonは？

組み込み型とコンテナデータ型(複合型)があります。

- [組み込み型](https://docs.python.org/ja/3/library/stdtypes.html)
- [コンテナデータ型](https://docs.python.org/ja/3/library/collections.html) : 標準ライブラリ`collections`に含まれています

また、`Numpy`の`ndarray`などの外部ライブラリが提供するデータ構造や自前で実装したデータ構造などは複合型に該当します。

そして、これらすべてのデータ型は**オブジェクト**からできています。  
詳しくは[Pythonのオブジェクトとクラスのビジュアルガイド](https://postd.cc/pythons-objects-and-classes-a-visual-guide/)を読んでみてください。

## 4. 型付けについて

分類としては、大きく2観点あります。  
(名前的型付けと構造的型付けにはポリモーフィズムの章で触れます)

- 動的/静的型付け
- 強い/弱い型付け

また、大前提として「動的」だから良いとか「強い」から良いとかはありません。  
チームの文化や個人の価値観に依存します。

### 4.1. 動的/静的型付け

ここでは便宜上よく使われている処理方式で動的/静的を区別しています。  
もちろん、インタプリタ言語でもコンパイルをサポートしているものはあるし、コンパイラ言語でもインタプリタのような逐次実行をサポートしているものもあります。

#### 静的型付け

コンパイル時に型が決まる(コンパイラ言語)

- Java, C, C#, Go, Rust等
- コンパイラ言語は実行前にデータ型が正しいかを判断できる。
- コンパイルから実行までのハードルが高い反面、高速に動作する。

#### 動的型付け

実行時に型が決まる(インタプリタ言語)

- Python, Ruby, Perl, PHP等
- インタプリタは実行時までデータ型が分からない。
- 実行が気軽に行える反面、機械語に逐次翻訳されるので速度は遅め。

現在では、動的型付け・静的型付けの各特徴を使い分ける漸進的型付け(Gradual Typing)の機能を導入している言語もあります。  
(詳細は「[What is Gradual Typing](https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)」や「[What is Gradual Typing: 漸進的型付けとは何か](https://qiita.com/t2y/items/0a604384e18db0944398)」がオススメです)

#### 漸進的型付け

実行前に型推論される(決まるわけではない)

- Python, TypeScript等
- 現状、動的型付け言語に型アノテーションを導入して実現するケースが多い。
  - C言語のauto等は静的型付け言語に動的な特徴が足されていたりします。
- Pythonだと型アノテーションに強制力がなかったりするし、TypeScriptだと型が表現されないとany型になったりと、言語によって実現範囲が異なります。

まとめると、Pythonは「動的型付け」か「漸進的型付け」言語にあたります。
どちらで書くべきかと言われると、漸進的型付け言語として型アノテーションを賢く使うべきです。

例えば、**ハンガリアン記法**のようにデータ型を変数名に含む必要がなくなります。(エディタのツールチップ等が使えないプロジェクト等を除く)

```py
# NG
drink_str_list = []
# OK (Python3.8 は List[str])
drinks: list[str] = []
```

で、右辺で型が明らかな場合は、わざわざ型を書く必要はありません。

```py
# NG
id: int = 1
# OK
id = 1
# OK (明らかだが型そのものが大事な場合)
DEFAULT_ID: Final[int] = 1
```

ちなみに、`Final`などの型アノテーションを利用する場合、型チェッカーを導入することになると思うのですが、「mypy」を使用するほうが無難です。「Pylance(Pyright)」だと、PEPで定義されたエラーやワーニングが出ないこともあります。 ([PEP-0591](https://peps.python.org/pep-0591/#reference-implementation)参照)  
ただPylance(Pyright)はmypyよりも便利な場面も多いので、私は最近だとPylance(Pyright)を使っています。  
この辺もうちょっとなんとかならないかなと思ったりします…。

### 4.2. 強い/弱い型付け

強い、弱いの定義は割りとまちまち([この記事](https://matarillo.hatenadiary.jp/entry/20121017/p1)を参照)  
今回は型安全に触れておきたいため、言及します。

#### 強い型付け

型の安全性が言語仕様で保たれているもの

- Java, C#, Python, Ruby 等
- 型安全: 型によるバグの検知ができる(静的・動的に関係なく)
- null安全とは限らない。(JavaやPython等は許容されている)
  - Pythonは型を定義しない場合はnull(`None`)を許容すべきではないです。(意図しないデータ型を混入させたくないため)

#### 弱い型付け

型の安全性が保証されないもの

- C, C++, JavaScript 等
- 型安全が保たれていない

型安全が保たれていないとどうなるかは下記のJavaScriptの例を見ると分かりやすいかと思います。

```js
console.log(1 + "1");
>>> 11
```

このように、int型とstring型で意図しない結合ができてしまいます。Pythonだとどうかと言うと、下記のようなエラーになります。

```py
print(1 + "1")
>>> 1 + "1" 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

余談になりますが、Pythonがこの観点で必ずしも型安全かというと少し違います。  
例えば下記のようにint型とbool型の計算は可能なんですよね。

```py
print(1 + True)
>>> 2
```

これはどういうことかというと、bool型はint型のサブクラスだからなんですよね。  
(Trueは1, Falseは0で計算されます。)  

```py
print(issubclass(bool, int))
>>> True
```

このように、型安全とされている言語にも言語仕様による落とし穴とか違いがあるので気をつけましょう。

## 5. OOPにおけるデータ型

> オブジェクト指向プログラミング(Object-Oriented Programming, OOP)とは、「オブジェクト」という概念に基づいたプログラミングパラダイムの一つである。

([Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)参照)

OOPを構成する3要素は以下になります。

- クラス(継承、抽象化)
- カプセル化
- ポリモーフィズム

今回はOOPのクラスとポリモーフィズムをデータ型の観点から解説します。

### 5.1. クラス

クラスとは「データと処理をまとめて隠蔽し、たくさん作る」ための機能です。クラスを、「抽象化」や「継承」することでクラスを分類することもできます。  
今回は、抽象化に着目して説明します。抽象化の方法として**抽象クラス**(`abstract`)を定義する場合と**インターフェース**(`interface`)を定義する場合があります。  
それぞれの違いは以下になります。

#### 抽象クラス

「動物と聞かれると、こういうイメージです」を定義する感じです。

- 処理が書ける(オーバーライドで書き換える前提のため)
- 継承元の抽象クラスは1つのみ

#### インターフェース

「動物にはこういう特徴がある」といったスペックを定義する感じです。

- 処理が書けない
- インターフェースを複数組み合わせたりできる
- 多重継承可(振る舞いが描かれるわけはないため)

### 5.2. ポリモーフィズム

ポリモーフィズムは日本語で「多態性」、「多相性」等と呼ばれるものです。  
少し具体的に説明すると、「クラスの類似するメソッド(関数)を同じような動作としてみなす」ということです。

よくある`Animal`クラスを例に確認してみましょう。  
(ここではJavaで記載します。Pythonの例は後で記載します。)

```Java
abstract class Animal {
    abstract String cry();
} 
```

動物の抽象クラスです。これらを継承したクラスを作成してみましょう。

```Java
class Dog extends Animal {
  String cry(){
    return "ワン";
  }
}

class Cat extends Animal {
  String cry(){
    return "ニャー"
  }
}
```

これらクラスの`cry`メソッドは動物(`Animal`)の種類に問わず必ず持つ動作です。よってこれらのメソッドを使う側は動物の種類に問わず、鳴いてもらうことが可能です。

ここでは、飼い主(`PetOwner`)が笛を吹く(`blowWhistle`)と鳴く処理を実装しています。

```Java
class PetOwner {
  void blowWhistle(Animal animal){
    System.out.println(animal.cry());
  }
}
```

こんな感じで実装できるので、わざわざ「Dogのとき」、「Catのとき」のような処理を書く手間が省けます。

以上がポリモーフィズムのよくある具体的な説明なんですが、少しデータ型を絡めた解説をします。

ポリモーフィズムを実現する方法は、静的型付け言語と動的型付け言語で少々異なります。静的型付け言語では下記のように継承元のクラスやインターフェースの参照情報が必要になります。

> 多くの静的型付け言語では継承やインターフェースを実装していることを明示する必要があります。これをNominal Subtypingと呼びます。Nominal Subtypingの場合、前もって宣言されていなければ期待される振る舞いを持っていてもコンパイル時にエラーになってしまいます。

([RubyKaigi 2016 基調講演](https://gihyo.jp/news/report/01/rubykaigi2016/0001)のレポート参照)

これに対し、動的型付け言語では継承元のクラスやインターフェースの参照情報を必要とせず、メソッドや関数だけを検証します。これを「ダックタイピング」と呼びます。

以下に２つの違いをまとめます。

**Nominal Subtyping(名称的部分型付け)**: 親クラス情報が同じ場合、同じメソッドと認識される。

- Java, C#等
- ポリモーフィズムの縛りが強いため、厳密に実装できる。
- 静的型付け言語はこちらに該当します。(Goは例外で後述します)

**ダックタイピング**: どのようなクラスでも、特定のメソッドがあれば同じと認識される。

- Python, Ruby, JavaScript, PHP等
- ポリモーフィズムの縛りが少ないため、柔軟に実装できる。
- 動的型付け言語はこちらに該当します。

また、Goのように静的型付け言語でありながらダックタイピングのようなデータ解析ができる言語もあります。これを **Structural Subtyping(構造的部分型付け)** と呼びます。

### 5.3. Pythonで意識することは？

Pythonに、**構造体**や**インターフェース**は存在しません。  
そのため、それらはクラスや抽象基底クラスで表現することになります。  



## 6. おわりに

データ型について最低限知っておいてほしいことを解説しました。  
Python自体はデータ型について意識がなくてもふわっと書けてしまう言語です。初めて触れる言語がPythonだとこういった意識を持つ方が難しいレベルです。  
私自身も初めての言語がPythonで、ある程度書けるようになった後もこういったデータ型の意識を持つことに苦戦しました。  
そういった方々の一助になれば幸いです。
