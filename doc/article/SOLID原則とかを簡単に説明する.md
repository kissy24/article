下記原則・知識を理解・説明・実践できることを前提としています。

## SOLID 原則(特に単一責任の原則)

[https://postd.cc/solid-principles-every-developer-should-know/:](https://postd.cc/solid-principles-every-developer-should-know/:)

ソフトウェア設計をより平易かつ柔軟にして保守しやすくすることが目的
以下の 5 つの原則があります。「単一責任の原則」だけ手厚く説明します。(他はさらっといきます)

- 単一責任の原則(Single-responsibility principle)
- 開放閉鎖の原則（Open/closed principle）
- リスコフの置換原則（Liskov substitution principle）
- インターフェース分離の原則 (Interface segregation principle)
- 依存性逆転の原則（Dependency inversion principle）

## ⅰ. 単一責任の原則

クラスは 1 つのことだけ責任を負うべきです。もし複数の責任を負っているとすれば、それは連動してしまいます。 1 つの責任への変更が、他の責任への変更をもたらしてしまいます。
＊ 最強の原則。これさえ守れば、OOP における多くの設計問題を解消することができます。(クラス以外にも適用できる)
1 つの責任: クラスの存在理由・振る舞いなどが 1 つであること。下記のようなことを意識すると分かりやすい。

- クラス名: 具体的で名詞か複合名詞であること。
  - And は確実に 2 つ以上の意味合いを持っているので NG
  - 名前が長すぎたり、抽象的すぎると意図せず複数の意味合いを持ってしまうので NG
- docstring: クラス名と祖語がないこと。
  - クラス名は 1 つの意味合いなのに、docstring は 2 つ以上の意味合いを持っていないか注意。
- メンバ変数: クラス名から明らかに類推できない変数が入っていないこと
  - メンバは基本的にクラス名と同種のカテゴリの物が入っている
- クラス関数: 動詞であること。クラスが主語になっていること。
  - クラスが主語でないと確実に責任範囲外です。
  - クラス関数の目的語にも注意。生成物が明らかにクラス名と関係のないことをしている場合も多々あります。
- 処理: クラス名、docstring で説明されている内容以上のことをしていないこと。
  - クラス名の内容を達成するための処理は全て責任範囲内です。(クラスが抽象的だと破綻する)
  - クラス名の範囲外の処理は責任範囲外です。別の処理に持たせるかクラス名を見直しましょう。
    変更: 1 つの責任に対する変更。変更後も 1 つの責任になっていること

## ⅱ. 開放閉鎖の原則

ソフトウェアのエンティティ（クラス、モジュール、関数）は拡張に対して開き、修正に対して閉じていなければならない。
親クラスの構成を弄らない。そういった追加は子クラスでやる。

- よくあるのは親クラスの条件分岐が肥大化するケース。各条件は子クラスで実装しましょう。
- 継承は使いたくないのでこういうのはインターフェースかダックタイピングで対応しましょう。

## ⅲ. リスコフの置換原則

スーパークラスは、そのサブクラスで代用可能でなければならない
親クラスで定義したメソッドは子クラスでも全てできるようにするということ。

- インターフェースの実装であれば、あまり問題にならない。

## ⅳ. インターフェース分離の原則

顧客に特化した細粒度のインタフェースを作れ 顧客は自分たちが使わないインターフェースに依存することを強いられるべきではない
インターフェースは「1 つの責任」を持つように実装されるべきということ。

- 単一責任の原則がインターフェースにも適用できるということ

## ⅴ. 依存性逆転の原則

依存性は、具体化ではなく抽象化でなければならない。 A. 高水準モジュールは低水準モジュールに依存してはならない。両者は、抽象化に依存するべきである。 B. 抽象化は、詳細に依存してはならない。詳細は、抽象化に依存するべきである。
インターフェース -> 実装クラス -> 実装クラスを継承したクラス を作るべきという話。

- 実装クラスを継承したクラスは実装クラスではなく、インターフェースの内容が満たせていれば OK
  - ただし、実装クラスと実装クラスの継承クラスに乖離があると「リスコフの置換原則」で NG になる
- mix-in とかもこの発想。
- 多重継承になるので基本的にしないのがおススメ

1. DRY 原則
   [https://ja.wikipedia.org/wiki/Don't_repeat_yourself より](https://ja.wikipedia.org/wiki/Don%27t_repeat_yourself%E3%82%88%E3%82%8A)
   Don’t repeat yourself (DRY) あるいは Single Source of truth(英)は、特にコンピューティングの領域で、重複を防ぐ考え方である。この哲学は、情報の重複は変更の困難さを増大し透明性を減少させ、不一致を生じる可能性につながるため、重複するべきでないことを強調する。
   つまり、「繰り返しを避け、重複箇所を排除すること」である。この原則は、同じ意味合いの処理にのみ適用してください。 異なる意味合いのものでたまたま処理が似ているだけのものは、将来的に処理が別物になるかもしれません。
2. YAGNI の原則
   [https://ja.wikipedia.org/wiki/YAGNI](https://ja.wikipedia.org/wiki/YAGNI) -> 機能は実際に必要となるまでは追加しないのがよい 将来的にどうなるか分からないことを考慮する必要はないです。その時に変更しましょう。 ただし、処理自体の拡張性や変更容易性を損なってよいということではないです。あくまで機能のお話です。
3. テストファースト
   XP や TDD と区別している。あくまでテストを先に書くという意味合いです。 課題では、TDD を正当に評価することが難しいため、最初にテストで設計を全て書いてもらいます。
4. 結合度・凝集度
   結合度・凝集度にはhttps://www.affordd.jp/koha_hp/KeyWords/KW.Coupling.htmlがあります。 結合度はレベルが低く、凝集度はレベルが高くなるほど基本的に良いとされています。 ただ、最も良い状態に無理やり持っていくことが必ずしも良いことではないので注意しましょう。 (1 つのクラスに定義するメンバ変数やメソッドの意味的なまとまりを強くして、クラス間のやり取りを少なくすることが望ましい。)
   結合度: クラスやモジュール間で、呼び出し関係にあるメソッドの結び付きの強さを表す指標

- 基本的に、クラスやモジュール間のやり取りが密接になるほどこの度合いが上がります。
- 継承は密結合になりやすいので注意。(親クラスとの関係が密接になるので)
  - 継承より委譲が好ましい。できるならば、委譲よりもデータのみのやり取りが望ましい。
- クラスやモジュールの責任が複数以上になると、他のクラス、モジュールと結合している可能性が高いです。
  - 単一責任の原則を守ることで結合度を低く保つことが可能です。
    凝集度: クラスやモジュール内の機能要素と情報要素間の関連性の強さを表す指標
- メンバ変数を操作するメソッドのみで構成されているクラスほど凝集度が高いです。
- クラスやモジュールの責任が複数以上になると、凝集度は高く見えますが密結合になりがちです。
- 意味まとまりになっていない構造体やクラスメソッドの凝集度は低いです。
  - データと処理のまとまりになっていない構造は「単一責任の原則」を満たせていないと凝集度の低い状態になります。
  - 逆に「単一責任の原則」を満たせている構造体やクラスメソッドは凝集度的に問題はないです。
